/*
 * JPPF.
 * Copyright (C) 2005-2014 JPPF Team.
 * http://www.jppf.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace org.jppf.dotnet {
  using System;
  using java.util.concurrent;
  using javax.management;
  using org.jppf.client;
  using org.jppf.client.concurrent;
  using org.jppf.client.@event;
  using org.jppf.client.monitoring.topology;
  using org.jppf.node.protocol;
  using net.sf.jni4net;
  using org.jppf.management;
  using org.jppf.management.forwarding;
  using org.jppf.management.generated;

  /// <summary>Extensions to the C# proxy classes generated by jni4net for the JPPFJob class.</summary>
  public static class JPPFJobExtensions {

    /// <summary>Add a .Net task to the specified job. The .Net task is serialized and the resulting byte[] is
    /// held by the returned <c>DotnetTaskWrapper</c> instance.
    /// <para>This is a method extension to the JPPFJob proxy class generated by jni4net.</para></summary>
    /// <param name="job">The job to add the task to</param>
    /// <param name="task">The task to add</param>
    /// <returns>A <c>Task</c> instance</returns>
    public static Task add(this JPPFJob job, BaseDotnetTask task) {
      return job.add(task, false);
    }

    /// <summary>Add a .Net task to the specified job. The .Net task is serialized and the resulting byte[] is
    /// held by the returned <c>DotnetTaskWrapper</c> instance on the Java side.
    /// <para>This is a method extension to the JPPFJob proxy class generated by jni4net.</para></summary>
    /// <param name="job">The job to add the task to</param>
    /// <param name="task">The task to add</param>
    /// <param name="loggingEnabled">Whether the Java wrapper for this task will print messages to the console during its execution</param>
    /// <returns>A <c>Task</c> instance</returns>
    public static Task add(this JPPFJob job, BaseDotnetTask task, bool loggingEnabled) {
      DotnetSerializer ser = new DotnetSerializer();
      byte[] bytes = ser.Serialize(task);
      DotnetTaskWrapper dtw = new DotnetTaskWrapper(bytes);
      if (task.TimeoutSchedule != null) dtw.setTimeoutSchedule(task.TimeoutSchedule);
      dtw.setLoggingEnabled(loggingEnabled);
      return job.add(dtw);
    }

    /// <summary>Add a .Net job listener to the specified job.</summary>
    /// <param name="job">The job to add the listener to</param>
    /// <param name="listener">The listener to add</param>
    public static void addJobListener(this JPPFJob job, BaseDotnetJobListener listener) {
      //Console.WriteLine("adding job listener " + listener);
      job.addJobListener(new DotnetJobListenerWrapper(new DotnetJobEventDispatcher(listener)));
    }
  }

  /// <summary>Extensions to the C# proxy classes generated by jni4net for the JPPFJob class.</summary>
  public static class JPPFTaskExtensions {

    /// <summary>Convert a JPPF <c>Task</c> into a <c>BaseDotnetTask</c>.</summary>
    /// <param name="job">A JPPF job to which the task belongs</param>
    /// <param name="task">The task to convert</param>
    /// <returns>A <c>BaseDotnetTask</c> instance, or <c>null</c> if the input task is not an instance of <c>DotnetTaskWrapper</c></returns>
    public static BaseDotnetTask AsBaseDotnetTask(this Task task) {
      DotnetTaskWrapper dtw = task as DotnetTaskWrapper;
      if (dtw != null) {
        DotnetSerializer ser = new DotnetSerializer();
        return (BaseDotnetTask) ser.Deserialize(dtw.getBytes());
      }
      return null;
    }
  }

  /// <summary>Extensions to the C# proxy classes generated by jni4net for the JPPFJob class.</summary>
  public static class JPPFExecutorServiceExtensions {

    /// <summary>Submit a .Net task to the specified executor service</summary>
    /// <param name="executor">The executor service to submit the task to</param>
    /// <param name="task">The task to submit</param>
    /// <returns>A <c>Future</c> instance</returns>
    public static Future Submit(this JPPFExecutorService executor, BaseDotnetTask task) {
      DotnetSerializer ser = new DotnetSerializer();
      byte[] bytes = ser.Serialize(task);
      DotnetTaskWrapper dtw = new DotnetTaskWrapper(bytes);
      //if (task.TimeoutSchedule != null) dtw.setTimeoutSchedule(task.TimeoutSchedule);
      dtw.setLoggingEnabled(false);
      return executor.submit(dtw);
    }

    /// <summary>Submit a .Net task to the specified completion service</summary>
    /// <param name="executor">The compeletion service to submit the task to</param>
    /// <param name="task">The task to submit</param>
    /// <returns>A <c>Future</c> instance</returns>
    public static Future Submit(this JPPFCompletionService completionService, BaseDotnetTask task) {
      DotnetSerializer ser = new DotnetSerializer();
      byte[] bytes = ser.Serialize(task);
      DotnetTaskWrapper dtw = new DotnetTaskWrapper(bytes);
      //if (task.TimeoutSchedule != null) dtw.setTimeoutSchedule(task.TimeoutSchedule);
      dtw.setLoggingEnabled(false);
      return completionService.submit(dtw, dtw);
    }
  }

  /// <summary>Extensions to JPPF management APIs.</summary>
  public static class JPPFManagementExtensions {
    /// <summary>Register a notification listener with the specified MBean.</summary>
    /// <param name="proxy">a proxy to the MBean</param>
    /// <param name="listener">the listener to register</param>
    /// <param name="handback"></param>
    public static void AddNotificationListener(this AbstractMBeanStaticProxy proxy, BaseDotnetNotificationListener listener, object handback) {
      //Console.WriteLine("adding notification listener " + listener + " to " + proxy);
      proxy.addNotificationListener(new DotnetNotificationListenerWrapper(new DotnetNotificationDispatcher(listener, handback)), null, null);
    }

    /// <summary>Register a listener which forward node notifications via the driver</summary>
    /// <param name="jmx">holds the connection to the driver's JMX server</param>
    /// <param name="selector">specifies the nodes from which notifications are forwarded</param>
    /// <param name="mbeanName">the name of the node MBean for which notifications are forwarded</param>
    /// <param name="listener">the listener to register</param>
    /// <param name="handback">an arbitrary object provided when the listerner was registered</param>
    /// <returns>A unique id under which the listener is registered</returns>
    public static string RegisterFowrwardingNotificationListener(this JMXDriverConnectionWrapper jmx, NodeSelector selector, string mbeanName, BaseDotnetNotificationListener listener, object handback) {
      NotificationListener javaListener = new DotnetNotificationListenerWrapper(new DotnetNotificationDispatcher(listener, handback));
      String id = jmx.registerForwardingNotificationListener(selector, mbeanName, javaListener, null, null);
      //Console.WriteLine("added forwarding notification listener " + listener + " to " + jmx + " with id=" + id);
      return id;
    }
  }

  /// <summary>Extensions to JPPF management APIs.</summary>
  public static class TopologyManagerExtensions {
    /// <summary>Register a topology listener with the topology manager.</summary>
    /// <param name="manager">The topology manager to add the listener to</param>
    /// <param name="listener">the listener to register</param>
    public static void AddTopologyListener(this TopologyManager manager, BaseDotnetTopologyListener listener) {
      manager.addTopologyListener(new DotnetTopologyListenerWrapper(new DotnetTopologyEventDispatcher(listener)));
    }
  }

  /// <summary>Extensions to jni4net APIs.</summary>
  public static class Jni4netExtensions {

    /// <summary>Add a list of semicolumn-separated paths to the BridgeSetup JVM classpath.
    /// <para>This is a convenience method which calls <c>BridgeSetup.AddClassPath(path)</c> for each path in the list</para></summary>
    /// <param name="setup">the <c>BridgeSetup</c> instance</param>
    /// <param name="paths">A string containing file paths separated by semicolumn characters</param>
    public static void AddClassPaths(this BridgeSetup setup, string paths) {
      if (paths != null) {
        foreach (string path in paths.Split(';')) setup.AddClassPath(path);
      }
    }

    /// <summary>Add a list of semicolumn-separated files in the specified directory to the BridgeSetup JVM classpath.
    /// <para>This is a convenience method which calls <c>BridgeSetup.AddClassPath(dir + "/" + file)</c> for each file in the list</para></summary>
    /// <param name="setup">the <c>BridgeSetup</c> instance</param>
    /// <param name="dir">the path of the enclosing directory</param>
    /// <param name="files">A string containing file names separated by semicolumn characters</param>
    public static void AddClassPaths(this BridgeSetup setup, string dir, string files) {
      if ((dir != null) && (files != null)) {
        foreach (string file in files.Split(';')) setup.AddClassPath(dir + "/" + file);
      }
    }
  }
}
