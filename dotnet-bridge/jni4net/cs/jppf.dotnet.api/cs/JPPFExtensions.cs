namespace org.jppf.dotnet {
  using System;
  using org.jppf.client;
  using org.jppf.client.@event;
  using org.jppf.node.protocol;
  using net.sf.jni4net;
  using org.jppf.management;
  using org.jppf.management.forwarding;

  /// <summary>Extensions to the C# proxy classes generated by jni4net for the JPPF Java APIs.</summary>
  public static class JPPFExtensions {

    /// <summary>Add a .Net task to the specified job. The .Net task is serialized and the resulting byte[] is
    /// held by the returned <c>DotnetTaskWrapper</c> instance.
    /// <para>This is a method extension to the JPPFJob proxy class generated by jni4net.</para></summary>
    /// <param name="job">The job to add the task to</param>
    /// <param name="task">The task to add</param>
    /// <returns>A <c>Task</c> instance</returns>
    public static Task add(this JPPFJob job, BaseDotnetTask task) {
      DotnetSerializer ser = new DotnetSerializer();
      byte[] bytes = ser.Serialize(task);
      DotnetTaskWrapper dtw = new DotnetTaskWrapper(bytes);
      return job.add(dtw);
    }

    /// <summary>Add a .Net task to the specified job. The .Net is serailized and the resulting byte[] is
    /// held the returned <c>DotnetTaskWrapper</c> instance.
    /// <para>This is a method extension to the JPPFJob proxy class generated by jni4net.</para></summary>
    /// <param name="job">The job to add the task to</param>
    /// <param name="task">The task to add</param>
    /// <param name="loggingEnabled">Whether the Java wrapper for this task will print messages to the console during its execution</param>
    /// <returns>A <c>Task</c> instance</returns>
    public static Task add(this JPPFJob job, BaseDotnetTask task, bool loggingEnabled) {
      DotnetSerializer ser = new DotnetSerializer();
      byte[] bytes = ser.Serialize(task);
      DotnetTaskWrapper dtw = new DotnetTaskWrapper(bytes);
      dtw.setLoggingEnabled(loggingEnabled);
      return job.add(dtw);
    }

    /// <summary>Convert a JPPF <c>Task</c> into a <c>BaseDotnetTask</c>.</summary>
    /// <param name="job">A JPPF job to which the task belongs</param>
    /// <param name="task">The task to convert</param>
    /// <returns>A <c>BaseDotnetTask</c> instance, or <c>null</c> if the input task is not an instance of <c>DotnetTaskWrapper</c></returns>
    public static BaseDotnetTask asBaseDotnetTask(this JPPFJob job, Task task) {
      DotnetTaskWrapper dtw = task as DotnetTaskWrapper;
      if (dtw != null) {
        DotnetSerializer ser = new DotnetSerializer();
        return (BaseDotnetTask) ser.Deserialize(dtw.getBytes());
      }
      return null;
    }

    /// <summary>Add a .Net job listener to the specified job.</summary>
    /// <param name="job">The job to add the listener to</param>
    /// <param name="listener">The listener to add</param>
    public static void addJobListener(this JPPFJob job, BaseDotnetJobListener listener) {
      Console.WriteLine("adding job listener " + listener);
      job.addJobListener(new DotnetJobListenerWrapper(new DotnetJobEventDispatcher(job, listener)));
      //job.addJobListener(new DotnetJobListenerWrapper());
    }

    /// <summary>Add a list of semicolumn-separated paths to the BridgeSetup JVM classpath.
    /// <para>This is a convenience method which calls <c>BridgeSetup.AddClassPath(path)</c> for each path in the list</para></summary>
    /// <param name="setup">the <c>BridgeSetup</c> instance</param>
    /// <param name="paths">A string containg file paths separated by semicolumn characters</param>
    public static void AddClassPaths(this BridgeSetup setup, string paths) {
      if (paths != null) {
        foreach (string path in paths.Split(';')) setup.AddClassPath(path);
      }
    }

    /// <summary>Add a list of semicolumn-separated files in the specified directory to the BridgeSetup JVM classpath.
    /// <para>This is a convenience method which calls <c>BridgeSetup.AddClassPath(dir + "/" + file)</c> for each file in the list</para></summary>
    /// <param name="setup">the <c>BridgeSetup</c> instance</param>
    /// <param name="paths">the path of the enclosing directory</param>
    /// <param name="paths">A string containg file names separated by semicolumn characters</param>
    public static void AddClassPaths(this BridgeSetup setup, string dir, string files) {
      if ((dir != null) && (files != null)) {
        foreach (string file in files.Split(';')) setup.AddClassPath(dir + "/" + file);
      }
    }

    /*
    */
    public static object forwardInvoke(this JMXDriverConnectionWrapper jmx, NodeSelector selector, string mbeanName, string methodName, java.lang.Object[] parameters, string[] signature) {
      java.lang.String[] sig = null;
      if (signature != null) {
        Console.WriteLine("converting " + signature.Length + " strings:");
        sig = new java.lang.String[signature.Length];
        for (int i=0; i<signature.Length; i++) {
          Console.WriteLine("#" + i + " : value='" + signature[i] + "'");
          sig[i] = new java.lang.String(signature[i]);
        }
      }
      Console.WriteLine("invoking mbean");
      return jmx.forwardInvoke(selector, mbeanName, methodName, parameters, sig);
    }
  }
}
