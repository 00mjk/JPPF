/*
 * Java Parallel Processing Framework.
 *  Copyright (C) 2005-2009 JPPF Team. 
 * http://www.jppf.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	 http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jppf.server.protocol.commandline;

import java.io.*;
import java.net.*;
import java.util.*;

import org.apache.commons.io.IOUtils;
import org.jppf.process.ProcessWrapper;
import org.jppf.server.protocol.JPPFTask;
import org.jppf.utils.FileUtils;

/**
 * Instances of this class encapsulate the execution of an external process, program or shell script.<br>
 * This task starts and external process using command line arguments, environment variables, and a list
 * of input and/or output files to use or generated by the external process.<br>
 * This task also captures the standard and error output (i.e. equivalent to System.out and System.err) of the
 * external process.
 * @author Laurent Cohen
 */
public class CommandLineTask extends JPPFTask
{
	/**
	 * The list of command-line arguments.
	 */
	private List<String> commandList = new ArrayList<String>();
	/**
	 * The environment variables to set.
	 */
	private Map<String, String> env = new HashMap<String, String>();
	/**
	 * The directory to start the command in.
	 */
	private String startDir = null;
	/**
	 * A list of input artifacts to be used by the external program.
	 */
	private List<ExternalArtifact> inputArtifacts = new ArrayList<ExternalArtifact>();
	/**
	 * A list of output artifacts generated by the external program.
	 */
	private List<ExternalArtifact> outputArtifacts = new ArrayList<ExternalArtifact>();
	/**
	 * A list of callbacks invoked before the execution of the external program..
	 */
	private List<JPPFCallback> preProcessingCallbacks = new ArrayList<JPPFCallback>();
	/**
	 * A list of callbacks invoked after the execution of the external program..
	 */
	private List<JPPFCallback> postProcessingCallbacks = new ArrayList<JPPFCallback>();
	/**
	 * Content of the standard output for the process.
	 */
	private String standardOutput = null;
	/**
	 * Content of the error output for the process.
	 */
	private String errorOutput = null;
	/**
	 * Determines whether the process output should be captured.
	 */
	private boolean captureOutput = false;

	/**
	 * Create an instance of this class.
	 * @param commands the list of command-line arguments.
	 */
	public CommandLineTask(String...commands)
	{
		this(null, null, commands);
	}

	/**
	 * Create an instance of this class.
	 * @param env the environment variables to set.
	 * @param startDir the directory to start the command in.
	 * @param commands the list of command-line arguments.
	 */
	public CommandLineTask(Map<String, String> env, String startDir, String...commands)
	{
		if (commands != null)
		{
			for (String s: commands) commandList.add(s);
		}
		this.env = env;
		this.startDir = startDir;
	}

	/**
	 * Run the external program using the command line arguments, environment and artifacts provided.<br>
	 * The processing follows this sequence of steps: 
	 * <ol>
	 * <li>the input artifacts are copied onto the node host</li>
	 * <li>the pre-processing callbacks are executed</li>
	 * <li>the external program or script is executed</li>
	 * <li>the post-processing callbacks are executed</li>
	 * <li>the content of the output artifacts is fetched from the node host</li>
	 * </ol>
	 * @see java.lang.Runnable#run()
	 */
	public void run()
	{
		try
		{
			writeInputContent();
			for (JPPFCallback c: preProcessingCallbacks) c.run();
			ProcessBuilder builder = new ProcessBuilder();
			builder.command(commandList);
			if (startDir != null) builder.directory(new File(startDir));
			if (env != null)
			{
				Map map = builder.environment();
				for (Map.Entry e: env.entrySet()) map.put(e.getKey(), e.getValue());
			}
			Process p = builder.start();
			ProcessWrapper wrapper = new ProcessWrapper(p);
			p.waitFor();
			if (captureOutput)
			{
				StringBuilder sb = wrapper.getStandardOutput();
				if (sb != null) standardOutput = sb.toString();
				sb = wrapper.getErrorOutput();
				if (sb != null) errorOutput = sb.toString();
			}
			for (JPPFCallback c: postProcessingCallbacks) c.run();
			fetchOutputContent();
		}
		catch(Exception e)
		{
			setException(e);
		}
	}

	/**
	 * Get the list of input artifacts to be used by the external program.
	 * The returned list can be modified to add or remove artifacts.
	 * @return a list of <code>ExternalArtifact</code> instances.
	 */
	public List<ExternalArtifact> getInputArtifacts()
	{
		return inputArtifacts;
	}

	/**
	 * Get the list of output artifacts generated by the external program.
	 * The returned list can be modified to add or remove artifacts.
	 * @return a list of <code>ExternalArtifact</code> instances.
	 */
	public List<ExternalArtifact> getOutputArtifacts()
	{
		return outputArtifacts;
	}

	/**
	 * Add an artifact to the list of input artifacts in this task.
	 * @param artifact the artifact to add.
	 */
	public void addInputArtifact(ExternalArtifact artifact)
	{
		inputArtifacts.add(artifact);
	}

	/**
	 * Add an artifact to the list of output artifacts in this task.
	 * @param artifact the artifact to add.
	 */
	public void addOutputArtifact(ExternalArtifact artifact)
	{
		outputArtifacts.add(artifact);
	}

	/**
	 * Add a callback to the listr of pre-processing callbacks of this task.
	 * @param callback a <b>JPPFCallback</b> instance.
	 */
	public void addPreProcessingCallback(JPPFCallback callback)
	{
		preProcessingCallbacks.add(callback);
	}

	/**
	 * Add a callback to the listr of post-processing callbacks of this task.
	 * @param callback a <b>JPPFCallback</b> instance.
	 */
	public void addPostProcessingCallback(JPPFCallback callback)
	{
		postProcessingCallbacks.add(callback);
	}

	/**
	 * Determines whether the process output is captured.
	 * @return true if the output is cpatured, false otherwise.
	 */
	public boolean isCaptureOutput()
	{
		return captureOutput;
	}

	/**
	 * Specifies whether the process output is captured.
	 * @param captureOutput true if the output is cpatured, false otherwise.
	 */
	public void setCaptureOutput(boolean captureOutput)
	{
		this.captureOutput = captureOutput;
	}

	/**
	 * Get the content of the standard output for the process.
	 * @return the output as a string.
	 */
	public String getStandardOutput()
	{
		return standardOutput;
	}

	/**
	 * Get the content of the error output for the process.
	 * @return the output as a string.
	 */
	public String getErrorOutput()
	{
		return errorOutput;
	}

	/**
	 * Fetch the content of all input artifacts from their local location.
	 * @throws Exception an error occurred while reading the content.
	 */
	public void fetchInputContent() throws Exception
	{
		for (ExternalArtifact a: inputArtifacts)
		{
			a.setContent(readContentFromLocation(a.getLocalLocation()));
		}
	}

	/**
	 * Write the content of all output artifacts to their local location.
	 * @throws Exception an error occurred while reading the content.
	 */
	public void writeOutputContent() throws Exception
	{
		for (ExternalArtifact a: outputArtifacts)
		{
			writeContentToLocation(a.getLocalLocation(), a.getContent());
		}
	}

	/**
	 * Fetch the content of all output artifacts from their remote location.
	 * @throws Exception an error occurred while reading the content.
	 */
	public void fetchOutputContent() throws Exception
	{
		for (ExternalArtifact a: outputArtifacts)
		{
			a.setContent(readContentFromLocation(a.getRemoteLocation()));
		}
	}

	/**
	 * Write the content of all input artifacts to their remote location.
	 * @throws Exception an error occurred while reading the content.
	 */
	public void writeInputContent() throws Exception
	{
		for (ExternalArtifact a: outputArtifacts)
		{
			writeContentToLocation(a.getLocalLocation(), a.getContent());
		}
	}

	/**
	 * Fetch the content from a specified location.
	 * @param location the location to lookup for.
	 * @return the content as an array of bytes.
	 * @throws Exception if an error occurred finding the location or reading its content.
	 */
	private byte[] readContentFromLocation(Location location) throws Exception
	{
		InputStream is = null;
		byte[] content = null;
		try
		{
			if (location.getType() == Location.FILE)
			{
				is = FileUtils.getFileInputStream(location.getPath());
			}
			else
			{
				is = new URL(location.getPath()).openStream();
			}
			if (is != null) content = IOUtils.toByteArray(is);
		}
		finally
		{
			if (is != null) is.close();
		}
		return content;
	}

	/**
	 * Write the content to a specified location.
	 * @param location the location to lookup for.
	 * @param content the content to write as an array of bytes.
	 * @throws Exception if an error occurred finding the location or reading its content.
	 */
	private void writeContentToLocation(Location location, byte[] content) throws Exception
	{
		OutputStream os = null;
		try
		{
			if (location.getType() == Location.FILE)
			{
				os = FileUtils.getFileOutputStream(location.getPath());
			}
			else
			{
				URL url = new URL(location.getPath());
				URLConnection c = url.openConnection();
				c.setDoOutput(true);
				os = c.getOutputStream();
			}
			if (os != null) IOUtils.write(content, os);
		}
		finally
		{
			if (os != null)
			{
				os.flush();
				os.close();
			}
		}
	}
}
